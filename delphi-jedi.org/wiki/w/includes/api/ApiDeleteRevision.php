<?php

/*
 * Created on Feb 12, 2011
 * API for MediaWiki 1.14+
 *
 * Copyright (C) 2011 Florent Ouchet outchy@users.sourceforge.net
 * Parts of this file are from:
 *  -ApiDelete.php Copyright (C) 2007 Roan Kattouw <Firstname>.<Lastname>@home.nl
 *  -Article.php part of MediaWiki 1.14
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 * http://www.gnu.org/copyleft/gpl.html
 */

if (!defined('MEDIAWIKI')) {
	// Eclipse helper - will be ignored in production
	require_once ("ApiBase.php");
}

/**
 * API module that facilitates deleting pages. The API eqivalent of action=deleterevision.
 * Requires API write mode to be enabled.
 *
 * @ingroup API
 */
class ApiDeleteRevision extends ApiBase {

	public function __construct($main, $action) {
		parent :: __construct($main, $action);
	}

	/**
	 * Extracts the title, token, and reason from the request parameters and invokes
	 * the local delete() function with these as arguments. If the deletion succeeds, the
	 * details of the revision deleted and the reason for deletion are added to the
	 * result object.
	 */
	public function execute() {
		global $wgUser;
		$this->getMain()->requestWriteMode();
		$params = $this->extractRequestParams();

		$this->requireOnlyOneParameter($params, 'title', 'pageid');
		if(!isset($params['token']))
			$this->dieUsageMsg(array('missingparam', 'token'));

        if(!isset($params['revid']))
            $this->dieUsageMsg(array('missingparam', 'revid'));

		if(isset($params['title']))
		{
			$titleObj = Title::newFromText($params['title']);
			if(!$titleObj)
				$this->dieUsageMsg(array('invalidtitle', $params['title']));
		}
		else if(isset($params['pageid']))
		{
			$titleObj = Title::newFromID($params['pageid']);
			if(!$titleObj)
				$this->dieUsageMsg(array('nosuchpageid', $params['pageid']));
		}
		if(!$titleObj->exists())
			$this->dieUsageMsg(array('notanarticle'));

		$reason = (isset($params['reason']) ? $params['reason'] : NULL);
		if ($titleObj->getNamespace() == NS_FILE) {
	        // We don't support files here
			$this->dieUsageMsg(array('invalidtitle', $titleObj->getText()));
		} else {
			$articleObj = new Article($titleObj);
			$retval = self::delete($articleObj, $params['token'], intval($params['revid']), $reason);
			
			if(count($retval))
				// We don't care about multiple errors, just report one of them
				$this->dieUsageMsg(current($retval));
			
			if($params['watch'] || $wgUser->getOption('watchdeletion'))
				$articleObj->doWatch();
			else if($params['unwatch'])
				$articleObj->doUnwatch();
		}

		$r = array('title' => $titleObj->getPrefixedText(), 'reason' => $reason, 'revid' => $revid);
		$this->getResult()->addValue(null, $this->getModuleName(), $r);
	}

	private static function getPermissionsError(&$title, $token) {
		global $wgUser;
		
		// Check permissions
		$errors = $title->getUserPermissionsErrors('delete', $wgUser);
		if (count($errors) > 0) return $errors;
		
		// Check token
		if(!$wgUser->matchEditToken($token))
			return array(array('sessionfailure'));
		return array();
	}

	/**
	 * @param Article $article - Article object to work on
	 * @param string $token - Delete token (same as edit token)
     * @param integer $revid - revision to delete
	 * @param string $reason - Reason for the deletion. Autogenerated if NULL
	 * @return Title::getUserPermissionsErrors()-like array
	 */
	public function delete(&$article, $token, $revid, &$reason)
	{
		global $wgUser;
		$title = $article->getTitle();
		$errors = self::getPermissionsError($title, $token);
		if (count($errors)) return $errors;

        if ($article->getRevIdFetched() == $revid)
        {
    		return array(array('cannotdelete', $title->getPrefixedText()));
        }

		// Auto-generate a summary, if necessary
		if(is_null($reason))
		{
            $reason = 'delete revision '.$revid.' of page '.$title->getPrefixedText();
		}

		// We have to handle the revision deletion by hand
		if($this->doDeleteRevision(&$article, $revid, $reason)) {
			return array();
		}
		return array(array('cannotdelete', $title->getPrefixedText()));
	}

    public static function doDeleteRevision(&$article, $revid, $reason)
    {
   		$dbw = wfGetDB( DB_MASTER );
        $title = $article->getTitle();

		$ns = $title->getNamespace();
		$t = $title->getDBkey();
		$id = $id ? $id : $title->getArticleID( GAID_FOR_UPDATE );

		if( $t == '' || $id == 0 ) {
			return false;
		}

    	$bitfield = 'rev_deleted';

		$dbw->begin();
		// For now, shunt the revision data into the archive table.
		// Text is *not* removed from the text table; bulk storage
		// is left intact to avoid breaking block-compression or
		// immutable storage schemes.
		//
		// For backwards compatibility, note that some older archive
		// table entries will have ar_text and ar_flags fields still.
		//
		// In the future, we may keep revisions and mark them with
		// the rev_deleted field, which is reserved for this purpose.
		$dbw->insertSelect( 'archive', array( 'page', 'revision' ),
			array(
				'ar_namespace'  => 'page_namespace',
				'ar_title'      => 'page_title',
				'ar_comment'    => 'rev_comment',
				'ar_user'       => 'rev_user',
				'ar_user_text'  => 'rev_user_text',
				'ar_timestamp'  => 'rev_timestamp',
				'ar_minor_edit' => 'rev_minor_edit',
				'ar_rev_id'     => 'rev_id',
				'ar_text_id'    => 'rev_text_id',
				'ar_text'       => '\'\'', // Be explicit to appease
				'ar_flags'      => '\'\'', // MySQL's "strict mode"...
				'ar_len'        => 'rev_len',
				'ar_page_id'    => 'page_id',
				'ar_deleted'    => $bitfield
			), array(
                'rev_id' => $revid,
				'page_id' => $id,
				'page_id = rev_page'
			), __METHOD__
		);

        // delete the revision from the revision table
		$dbw->delete( 'revision', array( 'rev_page' => $id, 'rev_id' => $revid ), __METHOD__ );

		# Log the deletion
		$logtype = 'deleterevision';
		$log = new LogPage( $logtype );

		# Make sure logging got through
		$log->addEntry( 'delete', $title, $reason, array() );

		$dbw->commit();

		# Clear caches
		$title->invalidateCache();
		$title->purgeSquid();
		$title->touchLinks();

        return true;
    }

	public function mustBePosted() { return true; }

	public function getAllowedParams() {
		return array (
			'title' => null,
			'pageid' => array(
				ApiBase::PARAM_TYPE => 'integer'
			),
			'token' => null,
            'revid' => null,
			'reason' => null,
			'watch' => false,
			'unwatch' => false,
			'oldimage' => null
		);
	}

	public function getParamDescription() {
		return array (
			'title' => 'Title of the page you want to delete. Cannot be used together with pageid',
			'pageid' => 'Page ID of the page you want to delete. Cannot be used together with title',
			'token' => 'A delete token previously retrieved through prop=info',
            'revid' => 'ID of the revision to delete',
			'reason' => 'Reason for the deletion. If not set, an automatically generated reason will be used.',
			'watch' => 'Add the page to your watchlist',
			'unwatch' => 'Remove the page from your watchlist',
		);
	}

	public function getDescription() {
		return array(
			'Delete a revision.'
		);
	}

	protected function getExamples() {
		return array (
			'api.php?action=deleterevision&title=Main%20Page&revid=1234&token=123ABC',
			'api.php?action=deleterevision&title=Main%20Page&revid=1234&token=123ABC&reason=Cleaning old history'
		);
	}

	public function getVersion() {
		return __CLASS__ . ': $Id: ApiDeleteRevision.php 44541 2008-12-13 21:07:18Z mrzman $';
	}
}
